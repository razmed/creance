<?php
/**
 * Classe PDF - SANS WARNINGS
 * Spider Radar optimisé pour ressembler exactement à l'image de référence
 */

// Supprimer warnings AVANT require TCPDF
error_reporting(E_ERROR | E_PARSE);

require_once __DIR__ . '/../vendor/tecnickcom/tcpdf/tcpdf.php';

// Réactiver après chargement TCPDF
error_reporting(E_ALL & ~E_DEPRECATED & ~E_NOTICE & ~E_WARNING);

require_once __DIR__ . '/../config/constants.php';
require_once 'Creance.php';

class CreancePDF extends TCPDF {
    protected $title;
    protected $isLandscape;
    
    public function __construct($title = 'Rapport de Créances', $landscape = true) {
        $this->title = $title;
        $this->isLandscape = $landscape;
        
        $orientation = $landscape ? 'L' : 'P';
        $unit = 'mm';
        $format = 'A4';
        
        parent::__construct($orientation, $unit, $format, true, 'UTF-8', false);
        
        // Configuration du document
        $this->SetCreator(PDF_AUTHOR);
        $this->SetAuthor(PDF_AUTHOR);
        $this->SetTitle($this->title);
        $this->SetSubject('Rapport de gestion des créances');
        $this->SetKeywords('créances, provisions, rapport, gestion');
        
        // Configuration des marges
        $this->SetMargins(PDF_MARGIN_LEFT, PDF_MARGIN_TOP, PDF_MARGIN_RIGHT);
        $this->SetHeaderMargin(5);
        $this->SetFooterMargin(10);
        
        // Configuration de l'auto page break
        $this->SetAutoPageBreak(TRUE, PDF_MARGIN_BOTTOM);
        
        // Configuration de la police
        $this->SetFont('helvetica', '', 8);
    }
    
    public function Header() {
        $savedY = $this->GetY();
        
        $this->SetY(10);
        $this->SetFont('helvetica', 'B', 18);
        $this->SetTextColor(33, 37, 41);
        $this->Cell(0, 10, $this->title, 0, 1, 'C');
        
        $this->SetFont('helvetica', '', 9);
        $this->SetTextColor(108, 117, 125);
        
        $this->SetDrawColor(200, 200, 200);
        $this->SetLineWidth(0.3);
        $y = $this->GetY() + 1;
        
        $this->SetY($y + 3);
    }
    
    public function Footer() {
        $this->SetY(-15);
        $this->SetFont('helvetica', 'I', 8);
        $this->SetTextColor(128, 128, 128);
        $this->Cell(0, 10, 'Page ' . $this->getAliasNumPage() . ' / ' . $this->getAliasNbPages(), 0, 0, 'C');
    }
    
    public function generateReport($donnees, $stats = null, $filters = []) {
        $this->AddPage();
        
        if (!empty($filters)) {
            $this->addFiltersInfo($filters);
        }
        
        if ($stats) {
            $this->addStatsTable($stats);
        }
        
        $this->addCreancesTable($donnees);
    }
    
    private function addFiltersInfo($filters) {
        $this->SetFont('helvetica', 'B', 12);
        $this->Cell(0, 8, 'Filtres appliqués :', 0, 1, 'L');
        
        $this->SetFont('helvetica', '', 9);
        foreach ($filters as $column => $values) {
            if (!empty($values)) {
                $valuesList = is_array($values) ? implode(', ', $values) : $values;
                $this->Cell(0, 6, "• {$column} : {$valuesList}", 0, 1, 'L');
            }
        }
        
        $this->Ln(5);
    }
    
    private function addStatsTable($stats) {
        $this->SetFont('helvetica', 'B', 12);
        $this->Cell(0, 8, 'Tableau Créance-Provision', 0, 1, 'L');
        $this->Ln(2);
        
        $headers = ['CRÉANCE EN TTC', 'CRÉANCE EN HT', 'PROVISIONS EN TTC', 'PROVISIONS EN HT'];
        $values = [
            number_format($stats['creance_ttc'], 2, ',', ' '),
            number_format($stats['creance_ht'], 2, ',', ' '),
            number_format($stats['provision_ttc'], 2, ',', ' '),
            number_format($stats['provision_ht'], 2, ',', ' ')
        ];
        
        $cellWidth = $this->isLandscape ? 68 : 45;
        
        $this->SetFont('helvetica', 'B', 9);
        $this->SetFillColor(100, 100, 100);
        $this->SetTextColor(255, 255, 255);
        
        $startY = $this->GetY();
        $currentX = $this->GetX();
        
        foreach ($headers as $header) {
            $this->SetXY($currentX, $startY);
            $this->MultiCell($cellWidth, 10, $header, 1, 'C', true, 0);
            $currentX += $cellWidth;
        }
        $this->Ln(10);
        
        $this->SetFont('helvetica', 'B', 10);
        $this->SetFillColor(230, 230, 230);
        $this->SetTextColor(0, 0, 0);
        
        foreach ($values as $value) {
            $this->Cell($cellWidth, 10, $value, 1, 0, 'C', true);
        }
        $this->Ln();
        
        $this->Ln(10);
    }
    
    private function addCreancesTable($donnees) {
        if (empty($donnees)) {
            $this->SetFont('helvetica', 'I', 12);
            $this->Cell(0, 10, 'Aucune donnée à afficher', 0, 1, 'C');
            return;
        }
        
        $this->SetFont('helvetica', 'B', 12);
        $this->Cell(0, 8, 'Détail des Créances', 0, 1, 'L');
        $this->Ln(2);
        
        $headers = [
            'RÉGION', 'SECTEUR', 'CLIENT', "INTITULÉ\nMARCHÉ", 
            "N° FACTURE\n/ SITUATION", 'DATE', 'NATURE', 
            "MONTANT\nTOTAL", "ENCAISSE-\nMENT", "MONTANT\nCRÉANCE",
            "ÂGE", "%\nPROV.", "PROVISION\n2024", 'OBS.'
        ];
        
        $colWidths = [18, 18, 23, 28, 23, 16, 18, 20, 20, 20, 16, 13, 20, 14];
        
        $this->SetFont('helvetica', 'B', 6.5);
        $this->SetFillColor(60, 60, 60);
        $this->SetTextColor(255, 255, 255);
        
        $startY = $this->GetY();
        $maxHeight = 12;
        $currentX = $this->GetX();
        
        foreach ($headers as $i => $header) {
            $this->SetXY($currentX, $startY);
            $this->MultiCell($colWidths[$i], $maxHeight, $header, 1, 'C', true, 0);
            $currentX += $colWidths[$i];
        }
        
        $this->Ln($maxHeight);
        
        $this->SetFont('helvetica', '', 6);
        $this->SetTextColor(0, 0, 0);
        $fillColor1 = [245, 245, 245];
        $fillColor2 = [255, 255, 255];
        $currentFill = true;
        
        foreach ($donnees as $ligne) {
            $this->SetFillColor(
                $currentFill ? $fillColor1[0] : $fillColor2[0], 
                $currentFill ? $fillColor1[1] : $fillColor2[1], 
                $currentFill ? $fillColor1[2] : $fillColor2[2]
            );
            
            $rowData = [
                $this->truncateText($ligne['region'], 11),
                $this->truncateText($ligne['secteur'], 11),
                $this->truncateText($ligne['client'], 16),
                $this->truncateText($ligne['intitule_marche'], 22),
                $this->truncateText($ligne['num_facture_situation'], 16),
                $ligne['date_str'],
                $this->truncateText($ligne['nature'], 9),
                number_format($ligne['montant_total'], 0, ',', ' '),
                $ligne['montant_creance'] == 0 ? '' : number_format($ligne['encaissement'], 0, ',', ' '),
                number_format($ligne['montant_creance'], 0, ',', ' '),
                $ligne['age_annees'] . 'a',
                $ligne['pct_provision'] . '%',
                number_format($ligne['provision_2024'], 0, ',', ' '),
                $this->truncateText($ligne['observation'] ?? '', 8)
            ];
            
            $rowHeight = 7;
            foreach ($rowData as $i => $data) {
                $this->Cell($colWidths[$i], $rowHeight, $data, 1, 0, 'C', true);
            }
            $this->Ln();
            
            $currentFill = !$currentFill;
            
            if ($this->GetY() > 175) {
                $this->AddPage();
                
                $this->SetFont('helvetica', 'B', 6.5);
                $this->SetFillColor(60, 60, 60);
                $this->SetTextColor(255, 255, 255);
                
                $startY = $this->GetY();
                $currentX = $this->GetX();
                
                foreach ($headers as $i => $header) {
                    $this->SetXY($currentX, $startY);
                    $this->MultiCell($colWidths[$i], $maxHeight, $header, 1, 'C', true, 0);
                    $currentX += $colWidths[$i];
                }
                
                $this->Ln($maxHeight);
                $this->SetFont('helvetica', '', 6);
                $this->SetTextColor(0, 0, 0);
            }
        }
    }
    
    public function addCharts($chartImages) {
        if (empty($chartImages)) {
            return;
        }
        
        foreach ($chartImages as $title => $imagePath) {
            if (!file_exists($imagePath)) {
                continue;
            }
            
            $this->AddPage();
            
            $this->SetFont('helvetica', 'B', 14);
            $this->Cell(0, 10, $title, 0, 1, 'C');
            $this->Ln(5);
            
            $imageInfo = @getimagesize($imagePath);
            if ($imageInfo === false) {
                continue;
            }
            
            list($originalWidth, $originalHeight) = $imageInfo;
            
            $maxWidth = 260;
            $maxHeight = 160;
            
            $widthRatio = $maxWidth / $originalWidth;
            $heightRatio = $maxHeight / $originalHeight;
            $ratio = min($widthRatio, $heightRatio);
            
            $finalWidth = $originalWidth * $ratio;
            $finalHeight = $originalHeight * $ratio;
            
            $x = ($this->getPageWidth() - $finalWidth) / 2;
            $y = $this->GetY();
            
            $this->Image($imagePath, $x, $y, $finalWidth, $finalHeight, 'PNG');
        }
    }
    
    private function truncateText($text, $maxLength) {
        if (mb_strlen($text) <= $maxLength) {
            return $text;
        }
        
        return mb_substr($text, 0, $maxLength - 3) . '...';
    }
    
    private function formatValue($val) {
        if (abs($val) >= 1e9) {
            return number_format($val / 1e9, 2, '.', '') . 'B';
        } elseif (abs($val) >= 1e6) {
            return number_format($val / 1e6, 2, '.', '') . 'M';
        } elseif (abs($val) >= 1e3) {
            return number_format($val / 1e3, 0, '.', '') . 'K';
        } else {
            return number_format($val, 0, '.', '');
        }
    }
    
    public function generateBarChart($donnees, $outputPath) {
        $regionData = [];
        foreach ($donnees as $ligne) {
            $region = $ligne['region'];
            if (!isset($regionData[$region])) {
                $regionData[$region] = ['creances' => 0, 'provisions' => 0];
            }
            $regionData[$region]['creances'] += floatval($ligne['montant_creance']);
            $regionData[$region]['provisions'] += floatval($ligne['provision_2024']);
        }
        
        if (empty($regionData)) {
            return false;
        }
        
        $width = 1200;
        $height = 600;
        $image = imagecreatetruecolor($width, $height);
        if ($image === false) {
            error_log("BAR CHART: Impossible de créer l'image GD");
            return false;
        }
        
        $white = imagecolorallocate($image, 255, 255, 255);
        $black = imagecolorallocate($image, 0, 0, 0);
        $blue = imagecolorallocate($image, 0, 136, 254);
        $orange = imagecolorallocate($image, 255, 128, 66);
        $gray = imagecolorallocate($image, 200, 200, 200);
        
        imagefill($image, 0, 0, $white);
        imagestring($image, 5, 400, 30, 'Creances vs Provisions par Region', $black);
        
        $chartX = 80;
        $chartY = 80;
        $chartWidth = $width - 150;
        $chartHeight = $height - 150;
        
        $maxValue = 0;
        foreach ($regionData as $data) {
            $maxValue = max($maxValue, $data['creances'], $data['provisions']);
        }
        
        if ($maxValue == 0) {
            imagedestroy($image);
            return false;
        }
        
        imageline($image, $chartX, $chartY, $chartX, $chartY + $chartHeight, $black);
        imageline($image, $chartX, $chartY + $chartHeight, $chartX + $chartWidth, $chartY + $chartHeight, $black);
        
        for ($i = 0; $i <= 5; $i++) {
            $y = (int)($chartY + $chartHeight - ($i * $chartHeight / 5));
            $value = ($maxValue / 5) * $i;
            imageline($image, $chartX - 5, $y, $chartX, $y, $gray);
            imagestring($image, 2, 10, $y - 5, $this->formatValue($value), $black);
        }
        
        $regions = array_keys($regionData);
        $numRegions = count($regions);
        $barGroupWidth = $chartWidth / ($numRegions + 1);
        $barWidth = ($barGroupWidth / 3);
        
        foreach ($regions as $index => $region) {
            $x = (int)($chartX + ($index + 0.5) * $barGroupWidth);
            
            $creanceHeight = (int)(($regionData[$region]['creances'] / $maxValue) * $chartHeight);
            $creanceY = (int)($chartY + $chartHeight - $creanceHeight);
            imagefilledrectangle($image, 
                $x, $creanceY, 
                (int)($x + $barWidth), (int)($chartY + $chartHeight), 
                $blue);
            
            $provisionHeight = (int)(($regionData[$region]['provisions'] / $maxValue) * $chartHeight);
            $provisionY = (int)($chartY + $chartHeight - $provisionHeight);
            imagefilledrectangle($image, 
                (int)($x + $barWidth + 5), $provisionY, 
                (int)($x + 2 * $barWidth + 5), (int)($chartY + $chartHeight), 
                $orange);
            
            $regionLabel = substr($region, 0, 10);
            imagestring($image, 2, $x, (int)($chartY + $chartHeight + 10), $regionLabel, $black);
        }
        
        $legendX = $width - 200;
        $legendY = 100;
        imagefilledrectangle($image, $legendX, $legendY, $legendX + 30, $legendY + 20, $blue);
        imagestring($image, 3, $legendX + 40, $legendY + 5, 'Creances', $black);
        imagefilledrectangle($image, $legendX, $legendY + 30, $legendX + 30, $legendY + 50, $orange);
        imagestring($image, 3, $legendX + 40, $legendY + 35, 'Provisions', $black);
        
        imagepng($image, $outputPath);
        imagedestroy($image);
        
        return file_exists($outputPath);
    }

    public function generatePieChart($donnees, $outputPath) {
        $secteurData = [];
        foreach ($donnees as $ligne) {
            $secteur = $ligne['secteur'];
            if (!isset($secteurData[$secteur])) {
                $secteurData[$secteur] = 0;
            }
            $secteurData[$secteur] += floatval($ligne['montant_creance']);
        }
        
        if (empty($secteurData)) {
            return false;
        }
        
        $width = 1000;
        $height = 900;
        $image = @imagecreatetruecolor($width, $height);
        
        if ($image === false) {
            error_log("PIE CHART: Impossible de créer l'image GD");
            return false;
        }
        
        $white = imagecolorallocate($image, 255, 255, 255);
        $black = imagecolorallocate($image, 0, 0, 0);
        $colors = [
            imagecolorallocate($image, 0, 136, 254),
            imagecolorallocate($image, 0, 196, 159),
            imagecolorallocate($image, 255, 187, 40),
            imagecolorallocate($image, 255, 128, 66),
            imagecolorallocate($image, 136, 132, 216),
            imagecolorallocate($image, 255, 99, 132),
            imagecolorallocate($image, 54, 162, 235)
        ];
        
        imagefill($image, 0, 0, $white);
        imageantialias($image, true);
        
        imagestring($image, 5, 300, 30, 'Repartition par Secteur', $black);
        
        $total = array_sum($secteurData);
        if ($total == 0) {
            imagedestroy($image);
            return false;
        }
        
        $centerX = 380;
        $centerY = 400;
        $radius = 220;
        
        $currentAngle = 0;
        $colorIndex = 0;
        
        foreach ($secteurData as $secteur => $montant) {
            $sliceAngle = ($montant / $total) * 360;
            $endAngle = $currentAngle + $sliceAngle;
            
            imagefilledarc($image, $centerX, $centerY, $radius * 2, $radius * 2, 
                        (int)$currentAngle, (int)$endAngle, 
                        $colors[$colorIndex % count($colors)], IMG_ARC_PIE);
            
            $labelAngle = deg2rad($currentAngle + ($sliceAngle / 2));
            $labelDistance = $radius + 80;
            $labelX = (int)($centerX + cos($labelAngle) * $labelDistance);
            $labelY = (int)($centerY + sin($labelAngle) * $labelDistance);
            
            $percentage = ($montant / $total) * 100;
            
            $secteurLabel = substr($secteur, 0, 15);
            $percentLabel = number_format($percentage, 1) . '%';
            
            $bgColor = imagecolorallocatealpha($image, 255, 255, 255, 30);
            imagefilledrectangle($image, $labelX - 45, $labelY - 20, $labelX + 45, $labelY + 20, $bgColor);
            
            imagestring($image, 4, $labelX - 40, $labelY - 15, $secteurLabel, $black);
            imagestring($image, 4, $labelX - 20, $labelY, $percentLabel, $black);
            
            $currentAngle = $endAngle;
            $colorIndex++;
        }
        
        $legendY = 750;
        $legendX = 50;
        $colorIndex = 0;
        
        foreach ($secteurData as $secteur => $montant) {
            imagefilledrectangle($image, $legendX, $legendY, $legendX + 30, $legendY + 20, 
                            $colors[$colorIndex % count($colors)]);
            imagerectangle($image, $legendX, $legendY, $legendX + 30, $legendY + 20, $black);
            
            $secteurLabel = substr($secteur, 0, 20);
            imagestring($image, 3, $legendX + 35, $legendY + 3, $secteurLabel, $black);
            
            $legendX += 200;
            if ($legendX > 800) {
                $legendX = 50;
                $legendY += 30;
            }
            $colorIndex++;
        }
        
        $result = @imagepng($image, $outputPath);
        imagedestroy($image);
        
        return $result && file_exists($outputPath);
    }
    
    /**
     * =====================================================
     * SPIDER RADAR - REPRODUCTION EXACTE DE L'IMAGE
     * =====================================================
     */
    public function generateRadarChart($donnees, $outputPath) {
        // Agrégation par nature
        $naturesData = [];
        
        foreach ($donnees as $ligne) {
            $nature = $ligne['nature'];
            $montantCreance = floatval($ligne['montant_creance']);
            $provision = floatval($ligne['provision_2024']);
            
            if (!isset($naturesData[$nature])) {
                $naturesData[$nature] = ['creances' => 0.0, 'provisions' => 0.0];
            }
            $naturesData[$nature]['creances'] += $montantCreance;
            $naturesData[$nature]['provisions'] += $provision;
        }
        
        // Minimum 3 natures
        if (count($naturesData) < 3) {
            return false;
        }
        
        // DIMENSIONS EXACTES COMME L'IMAGE
        $width = 1400;
        $height = 1400;
        
        $image = @imagecreatetruecolor($width, $height);
        if ($image === false) {
            return false;
        }
        
        // COULEURS EXACTES DE L'IMAGE
        $white = imagecolorallocate($image, 255, 255, 255);
        $black = imagecolorallocate($image, 0, 0, 0);
        $darkText = imagecolorallocate($image, 44, 62, 80);
        
        // Bleu ciel + Orange (comme l'image)
        $blueStroke = imagecolorallocate($image, 0, 136, 254);      // #0088FE
        $orangeStroke = imagecolorallocate($image, 255, 128, 66);    // #FF8042
        
        // Avec transparence pour remplissage
        $blueFill = imagecolorallocatealpha($image, 0, 136, 254, 90);
        $orangeFill = imagecolorallocatealpha($image, 255, 128, 66, 90);
        
        // Grille
        $gridColor = imagecolorallocate($image, 220, 220, 220);
        $gridLight = imagecolorallocate($image, 240, 240, 240);
        
        // Fond blanc
        imagefill($image, 0, 0, $white);
        imageantialias($image, true);
        
        // TITRE
        $titleFont = 5;
        $titleText = 'Spider Radar par Nature - Creances et Provisions';
        $titleWidth = imagefontwidth($titleFont) * strlen($titleText);
        imagestring($image, $titleFont, ($width - $titleWidth) / 2, 50, $titleText, $darkText);
        
        // PARAMÈTRES DU RADAR
        $centerX = 700;
        $centerY = 720;
        $maxRadius = 480;
        
        // Valeur max
        $maxValue = 0;
        foreach ($naturesData as $data) {
            $maxValue = max($maxValue, $data['creances'], $data['provisions']);
        }
        
        if ($maxValue == 0) {
            imagedestroy($image);
            return false;
        }
        
        $natures = array_keys($naturesData);
        $n = count($natures);
        
        // === GRILLE CIRCULAIRE (5 niveaux comme l'image) ===
        imagesetthickness($image, 1);
        
        for ($level = 1; $level <= 5; $level++) {
            $radius = ($maxRadius / 5) * $level;
            $color = ($level == 5) ? $gridColor : $gridLight;
            
            // Cercle
            imageellipse($image, $centerX, $centerY, (int)($radius * 2), (int)($radius * 2), $color);
            
            // Label de valeur (comme l'image: à droite de chaque cercle)
            $levelValue = ($maxValue / 5) * $level;
            $labelText = $this->formatValue($levelValue);
            
            // Position droite (0°)
            $labelX = $centerX + (int)$radius + 20;
            $labelY = $centerY - 8;
            
            imagestring($image, 3, $labelX, $labelY, $labelText, $darkText);
        }
        
        // === AXES RADIAUX ===
        imagesetthickness($image, 1);
        
        for ($i = 0; $i < $n; $i++) {
            $angle = (2 * M_PI / $n) * $i - (M_PI / 2);
            
            $x = $centerX + (int)(cos($angle) * $maxRadius);
            $y = $centerY + (int)(sin($angle) * $maxRadius);
            
            imageline($image, $centerX, $centerY, $x, $y, $gridColor);
        }
        
        // === LABELS DES NATURES (externe) ===
        $labelDistance = $maxRadius + 80;
        $labelFont = 4;
        
        for ($i = 0; $i < $n; $i++) {
            $angle = (2 * M_PI / $n) * $i - (M_PI / 2);
            
            $labelX = $centerX + (int)(cos($angle) * $labelDistance);
            $labelY = $centerY + (int)(sin($angle) * $labelDistance);
            
            $nature = $natures[$i];
            $natureLabel = strlen($nature) > 15 ? substr($nature, 0, 15) : $nature;
            
            // Centrage selon position
            $textWidth = imagefontwidth($labelFont) * strlen($natureLabel);
            
            if ($angle >= -M_PI/4 && $angle <= M_PI/4) {
                // Droite
                $labelX += 10;
            } elseif ($angle > M_PI/4 && $angle < 3*M_PI/4) {
                // Bas
                $labelX -= (int)($textWidth / 2);
                $labelY += 10;
            } elseif ($angle >= 3*M_PI/4 || $angle <= -3*M_PI/4) {
                // Gauche
                $labelX -= $textWidth + 10;
            } else {
                // Haut
                $labelX -= (int)($textWidth / 2);
                $labelY -= 10;
            }
            
            imagestring($image, $labelFont, $labelX, $labelY, $natureLabel, $darkText);
        }
        
        // === POLYGONE CRÉANCES (BLEU) ===
        $pointsCreances= [];
        
        for ($i = 0; $i < $n; $i++) {
            $angle = (2 * M_PI / $n) * $i - (M_PI / 2);
            $value = $naturesData[$natures[$i]]['creances'];
            $radius = ($value / $maxValue) * $maxRadius;
            $pointsCreances[] = $centerX + (int)(cos($angle) * $radius);
            $pointsCreances[] = $centerY + (int)(sin($angle) * $radius);
        }
        
        // Remplissage bleu transparent
        if ($n >= 3 && count($pointsCreances) >= 6) {
            imagefilledpolygon($image, $pointsCreances, $blueFill);
        }
        
        // Contour bleu épais
        imagesetthickness($image, 3);
        if ($n >= 3 && count($pointsCreances) >= 6) {
            imagepolygon($image, $pointsCreances, $blueStroke);
        }
        imagesetthickness($image, 1);
        
        // Points bleus
        for ($i = 0; $i < $n; $i++) {
            $x = $pointsCreances[$i * 2];
            $y = $pointsCreances[$i * 2 + 1];
            
            // Cercle blanc fond
            imagefilledellipse($image, $x, $y, 14, 14, $white);
            // Cercle bleu
            imagefilledellipse($image, $x, $y, 12, 12, $blueStroke);
            
            // Valeur
            $value = $naturesData[$natures[$i]]['creances'];
            $valueText = $this->formatValue($value);
            
            $angle = (2 * M_PI / $n) * $i - (M_PI / 2);
            $offsetX = cos($angle) * 35;
            $offsetY = sin($angle) * 35;
            
            $textX = $x + (int)$offsetX;
            $textY = $y + (int)$offsetY - 5;
            
            imagestring($image, 3, $textX, $textY, $valueText, $blueStroke);
        }
        
        // === POLYGONE PROVISIONS (ORANGE) ===
        $pointsProvisions = [];
        
        for ($i = 0; $i < $n; $i++) {
            $angle = (2 * M_PI / $n) * $i - (M_PI / 2);
            $value = $naturesData[$natures[$i]]['provisions'];
            $radius = ($value / $maxValue) * $maxRadius;
            $pointsProvisions[] = $centerX + (int)(cos($angle) * $radius);
            $pointsProvisions[] = $centerY + (int)(sin($angle) * $radius);
        }
        
        // Remplissage orange transparent
        if ($n >= 3 && count($pointsProvisions) >= 6) {
            imagefilledpolygon($image, $pointsProvisions, $orangeFill);
        }
        
        // Contour orange épais
        imagesetthickness($image, 3);
        if ($n >= 3 && count($pointsProvisions) >= 6) {
            imagepolygon($image, $pointsProvisions, $orangeStroke);
        }
        imagesetthickness($image, 1);
        
        // Points orange
        for ($i = 0; $i < $n; $i++) {
            $x = $pointsProvisions[$i * 2];
            $y = $pointsProvisions[$i * 2 + 1];
            
            // Cercle blanc fond
            imagefilledellipse($image, $x, $y, 14, 14, $white);
            // Cercle orange
            imagefilledellipse($image, $x, $y, 12, 12, $orangeStroke);
            
            // Valeur
            $value = $naturesData[$natures[$i]]['provisions'];
            $valueText = $this->formatValue($value);
            
            $angle = (2 * M_PI / $n) * $i - (M_PI / 2);
            $offsetX = cos($angle) * 35;
            $offsetY = sin($angle) * 35;
            
            $textX = $x + (int)$offsetX;
            $textY = $y + (int)$offsetY + 10; // Décalé pour éviter collision
            
            imagestring($image, 3, $textX, $textY, $valueText, $orangeStroke);
        }
        
        // === LÉGENDE (BAS GAUCHE COMME L'IMAGE) ===
        $legendX = 100;
        $legendY = $height - 150;
        
        // Créances
        imagefilledellipse($image, $legendX, $legendY, 14, 14, $white);
        imagefilledellipse($image, $legendX, $legendY, 12, 12, $blueStroke);
        imagestring($image, 4, $legendX + 20, $legendY - 8, 'Creances', $darkText);
        
        // Provisions
        imagefilledellipse($image, $legendX, $legendY + 40, 14, 14, $white);
        imagefilledellipse($image, $legendX, $legendY + 40, 12, 12, $orangeStroke);
        imagestring($image, 4, $legendX + 20, $legendY + 32, 'Provisions', $darkText);
        
        // === SAUVEGARDER ===
        $result = @imagepng($image, $outputPath, 9);
        imagedestroy($image);
        
        if ($result === false || !file_exists($outputPath)) {
            error_log("RADAR CHART: Impossible de sauvegarder");
            return false;
        }
        
        return true;
    }
    
    public function canGenerateRadarChart($donnees) {
        $naturesUniques = [];
        foreach ($donnees as $ligne) {
            $nature = $ligne['nature'];
            if (!in_array($nature, $naturesUniques)) {
                $naturesUniques[] = $nature;
            }
        }
        return count($naturesUniques) >= 3;
    }
    
    public static function cleanupTempFiles($directory, $olderThanHours = 24) {
        if (!is_dir($directory)) {
            return;
        }
        
        $files = glob($directory . '/*');
        $now = time();
        
        foreach ($files as $file) {
            if (is_file($file)) {
                if ($now - filemtime($file) >= $olderThanHours * 3600) {
                    @unlink($file);
                }
            }
        }
    }
}

/**
 * Classe ReportGenerator
 */
class ReportGenerator {
    private $creance;
    private $tempDir;
    
    public function __construct() {
        $this->creance = new Creance();
        $this->tempDir = ROOT_PATH . '/temp/';
        
        if (!is_dir($this->tempDir)) {
            mkdir($this->tempDir, 0755, true);
        }
    }
    
    public function generateFullReport($filters = [], $archived = 0, $chartOptions = []) {
        try {
            $donnees = $this->creance->getAll($filters, $archived, 1, 10000);
            
            if (empty($donnees)) {
                throw new Exception('Aucune donnée à exporter');
            }
            
            $stats = $archived === 0 ? $this->creance->getStats($filters) : null;
            
            $title = $archived ? 'Rapport d\'Archive des Créances' : 'Rapport de Gestion des Créances';
            $pdf = new CreancePDF($title, true);
            
            $pdf->generateReport($donnees, $stats, $filters);
            
            $chartImages = [];
            if ($archived === 0 && !empty($chartOptions)) {
                
                if (!empty($chartOptions['bar_chart'])) {
                    $barChartPath = $this->tempDir . 'bar_chart_' . uniqid() . '.png';
                    if ($pdf->generateBarChart($donnees, $barChartPath)) {
                        $chartImages['Créances vs Provisions par Région'] = $barChartPath;
                    }
                }
                
                if (!empty($chartOptions['pie_chart'])) {
                    $pieChartPath = $this->tempDir . 'pie_chart_' . uniqid() . '.png';
                    if ($pdf->generatePieChart($donnees, $pieChartPath)) {
                        $chartImages['Répartition par Secteur'] = $pieChartPath;
                    }
                }
                
                if (!empty($chartOptions['radar_chart']) && $pdf->canGenerateRadarChart($donnees)) {
                    $radarChartPath = $this->tempDir . 'radar_chart_' . uniqid() . '.png';
                    if ($pdf->generateRadarChart($donnees, $radarChartPath)) {
                        $chartImages['Spider Radar par Nature'] = $radarChartPath;
                    }
                }
                
                if (!empty($chartImages)) {
                    $pdf->addCharts($chartImages);
                }
            }
            
            $exportsDir = ROOT_PATH . '/exports/';
            if (!is_dir($exportsDir)) {
                mkdir($exportsDir, 0755, true);
            }
            
            $filename = 'rapport_creances_' . date('Y-m-d_H-i-s') . '.pdf';
            $filepath = $exportsDir . $filename;
            
            $pdf->Output($filepath, 'F');
            
            foreach ($chartImages as $imagePath) {
                if (file_exists($imagePath)) {
                    @unlink($imagePath);
                }
            }
            
            return [
                'success' => true,
                'filename' => $filename,
                'filepath' => $filepath,
                'size' => filesize($filepath),
                'nb_lignes' => count($donnees),
                'filters_applied' => !empty($filters),
                'charts_count' => count($chartImages)
            ];
            
        } catch (Exception $e) {
            error_log("Erreur génération PDF: " . $e->getMessage());
            
            if (isset($chartImages)) {
                foreach ($chartImages as $imagePath) {
                    if (file_exists($imagePath)) {
                        @unlink($imagePath);
                    }
                }
            }
            
            return [
                'success' => false,
                'error' => $e->getMessage()
            ];
        }
    }
    
    public function canGenerateRadar($filters = [], $archived = 0) {
        try {
            $donnees = $this->creance->getAll($filters, $archived, 1, 10000);
            $pdf = new CreancePDF();
            return $pdf->canGenerateRadarChart($donnees);
        } catch (Exception $e) {
            return false;
        }
    }
    
    public function cleanupOldExports($daysOld = 7) {
        CreancePDF::cleanupTempFiles(ROOT_PATH . '/exports/', $daysOld * 24);
        CreancePDF::cleanupTempFiles($this->tempDir, 1);
    }
}
?>